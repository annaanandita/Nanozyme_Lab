# -*- coding: utf-8 -*-
"""NanozymeLab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lSnjbynwNYAALy4IPAWsuFPkyxLZSLTO
"""

# NanozymeLab — Gamified Computational Modeling of Nanozyme Kinetics for STEM
# Author: Anna Anandita

import math
import time
import numpy as np
import streamlit as st
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# ------------------------- Utilities -------------------------
R = 8.314462618  # J/(mol*K)
T_REF = 298.15   # K (25 °C)


def arrhenius_k(k_ref: float, Ea: float, T: float) -> float:
    return k_ref * math.exp(-Ea / R * (1.0 / T - 1.0 / T_REF))


def ph_activity_factor(ph: float, pKaA: float, pKaB: float) -> float:
    # bell-shaped factor from two ionizations
    fA = 1.0 / (1.0 + 10 ** (pKaA - ph))
    fB = 1.0 / (1.0 + 10.0 ** (ph - pKaB))
    return float(fA * fB)


def clamp01(x: float) -> float:
    return float(max(0.0, min(1.0, x)))


# ------------------------- Core Simulation -------------------------
DEFAULTS = dict(
    Etotal=1.0,
    S0=10.0,
    P0=0.0,
    k1ref=1.0,
    km1ref=0.5,
    k2ref=0.2,
    Ea1=20000.0,
    Eam1=15000.0,
    Ea2=25000.0,
    TdegC=25.0,
    pH=7.0,
    pKaA=6.0,
    pKaB=8.5,
    tmax=200.0,
    inhibition_type="None",
    inhibitor_I=0.0,
    Ki=1e12,  # effectively infinity
)


class SimResult:
    def __init__(self, t, S, ES, P, metrics, eff_rates):
        self.t = t
        self.S = S
        self.ES = ES
        self.P = P
        self.metrics = metrics
        self.eff_rates = eff_rates


def simulate_nanozyme(params: dict) -> SimResult:
    Etotal = float(params.get("Etotal", DEFAULTS["Etotal"]))
    S0 = float(params.get("S0", DEFAULTS["S0"]))
    P0 = float(params.get("P0", DEFAULTS["P0"]))
    k1ref = float(params.get("k1ref", DEFAULTS["k1ref"]))
    km1ref = float(params.get("km1ref", DEFAULTS["km1ref"]))
    k2ref = float(params.get("k2ref", DEFAULTS["k2ref"]))
    Ea1 = float(params.get("Ea1", DEFAULTS["Ea1"]))
    Eam1 = float(params.get("Eam1", DEFAULTS["Eam1"]))
    Ea2 = float(params.get("Ea2", DEFAULTS["Ea2"]))
    TdegC = float(params.get("TdegC", DEFAULTS["TdegC"]))
    pH = float(params.get("pH", DEFAULTS["pH"]))
    pKaA = float(params.get("pKaA", DEFAULTS["pKaA"]))
    pKaB = float(params.get("pKaB", DEFAULTS["pKaB"]))
    tmax = float(params.get("tmax", DEFAULTS["tmax"]))

    T = TdegC + 273.15
    k1T = arrhenius_k(k1ref, Ea1, T)
    km1T = arrhenius_k(km1ref, Eam1, T)
    k2T = arrhenius_k(k2ref, Ea2, T)

    pHfac = ph_activity_factor(pH, pKaA, pKaB)
    k1eff = k1T * pHfac
    km1eff = km1T * pHfac
    k2eff = k2T * pHfac

    inhib_type = params.get("inhibition_type", DEFAULTS["inhibition_type"]).lower()
    I = float(params.get("inhibitor_I", DEFAULTS["inhibitor_I"]))
    Ki = float(params.get("Ki", DEFAULTS["Ki"]))

    if inhib_type in ("competitive", "comp", "c") and Ki > 0:
        k1eff = k1eff / (1.0 + I / Ki)

    def rhs(t, y):
        S, ES, P = y
        Efree = Etotal - ES
        dS = -k1eff * Efree * S + km1eff * ES
        dES = k1eff * Efree * S - (km1eff + k2eff) * ES
        dP = k2eff * ES
        return [dS, dES, dP]

    # Integrate
    t_eval = np.linspace(0.0, tmax, 1000)
    y0 = [S0, 0.0, P0]
    sol = solve_ivp(rhs, t_span=(0.0, tmax), y0=y0, t_eval=t_eval, method="LSODA", rtol=1e-8, atol=1e-10)

    if not sol.success:
        raise RuntimeError("ODE solver failed: " + str(sol.message))

    S = sol.y[0]
    ES = sol.y[1]
    P = sol.y[2]

    # Metrics
    if len(sol.t) >= 3:
        v0 = float((P[2] - P[0]) / (sol.t[2] - sol.t[0]))
    else:
        v0 = float(k2eff * ES[0])

    vmax_app = float(k2eff * Etotal)
    target_P = 0.9 * (S0 + P0)
    idx = np.argmax(P >= target_P)
    if P[idx] >= target_P:
        t90 = float(sol.t[idx])
    else:
        t90 = float("nan")

    yield_frac = float(P[-1] / (S0 + P0)) if (S0 + P0) > 0 else float("nan")

    metrics = dict(v0=v0, vmaxApp=vmax_app, t90=t90, YieldAtTmax=yield_frac)
    eff_rates = dict(k1=k1eff, km1=km1eff, k2=k2eff, pHfactor=pHfac)

    return SimResult(sol.t, S, ES, P, metrics, eff_rates)


# ------------------------- Gamified Challenges -------------------------
BUILTIN_CHALLENGES = {
    "Level 1": {
        "name": "Hit 80% conversion in 120 s",
        "target": {"Yield": 0.80, "TimeLimit": 120.0, "MaxEtotal": 2.0},
        "hint": "Boost k2 or reduce km1; moderate Etotal to stay under budget.",
    },
    "Level 2": {
        "name": "Maximize initial rate under enzyme budget",
        "target": {"MinV0": 0.15, "TimeLimit": 100.0, "MaxEtotal": 1.0},
        "hint": "Raise k1 and k2 via temperature; use pH near optimal window.",
    },
    "Level 3": {
        "name": "Fast and Efficient (90% in 90 s)",
        "target": {"Yield": 0.90, "TimeLimit": 90.0, "MaxEtotal": 1.5},
        "hint": "Find the pH sweet-spot; avoid too low/high pH.",
    },
}


def score_run(params: dict, res: SimResult, target: dict) -> int:
    base = 100.0
    score = 0.0
    penalties = 0.0

    if "Yield" in target:
        y = clamp01(res.metrics["YieldAtTmax"])
        score = base * y
        if params["Etotal"] > target.get("MaxEtotal", 1e9):
            penalties += 25.0
        if params["tmax"] > target.get("TimeLimit", params["tmax"]):
            penalties += 15.0
    elif "MinV0" in target:
        v0 = res.metrics["v0"]
        score = base * clamp01(v0 / target["MinV0"])
        if params["Etotal"] > target.get("MaxEtotal", 1e9):
            penalties += 25.0
        if params["tmax"] > target.get("TimeLimit", params["tmax"]):
            penalties += 10.0

    return int(max(0.0, round(score - penalties)))


def mentor_tip(res: SimResult) -> str:
    pf = res.eff_rates["pHfactor"]
    v0 = res.metrics["v0"]
    if pf < 0.3:
        return "Your pH is far from optimal — move toward the pH window between pKaA and pKaB."
    if v0 < 0.05:
        return "Initial rate is low — consider increasing k2 (Ea2↓ or T↑) or Etotal."
    if np.isnan(res.metrics["t90"]):
        return "You may not reach high conversion within tmax — extend tmax or raise k2."
    return "Good direction — fine-tune pH and temperature for marginal gains."


# ------------------------- Streamlit UI -------------------------
st.set_page_config(page_title="NanozymeLab", layout="wide")
st.title("NanozymeLab — Gamified Nanozyme Kinetics (Game Edition)")

# Session state defaults
if "history" not in st.session_state:
    st.session_state.history = []  # list of dicts
if "game_active" not in st.session_state:
    st.session_state.game_active = False
if "game_start" not in st.session_state:
    st.session_state.game_start = None
if "best_score" not in st.session_state:
    st.session_state.best_score = 0
if "current_target" not in st.session_state:
    st.session_state.current_target = BUILTIN_CHALLENGES["Level 1"]["target"].copy()
if "current_hint" not in st.session_state:
    st.session_state.current_hint = BUILTIN_CHALLENGES["Level 1"]["hint"]
if "current_name" not in st.session_state:
    st.session_state.current_name = BUILTIN_CHALLENGES["Level 1"]["name"]

# Sidebar parameters
st.sidebar.header("Parameters")
Etotal = st.sidebar.slider("Etotal", 0.1, 5.0, float(DEFAULTS["Etotal"]), 0.1)
S0 = st.sidebar.slider("S0", 0.1, 50.0, float(DEFAULTS["S0"]), 0.1)
tmax = st.sidebar.slider("tmax (s)", 20.0, 400.0, float(DEFAULTS["tmax"]), 1.0)

st.sidebar.subheader("Kinetic Bases @ 25°C")
k1ref = st.sidebar.slider("k1ref", 0.01, 5.0, float(DEFAULTS["k1ref"]), 0.01)
km1ref = st.sidebar.slider("km1ref", 0.01, 5.0, float(DEFAULTS["km1ref"]), 0.01)
k2ref = st.sidebar.slider("k2ref", 0.001, 2.0, float(DEFAULTS["k2ref"]), 0.001)

st.sidebar.subheader("Activation Energies (J/mol)")
Ea1 = st.sidebar.slider("Ea1", 5000.0, 60000.0, float(DEFAULTS["Ea1"]), 500.0)
Eam1 = st.sidebar.slider("Eam1", 5000.0, 60000.0, float(DEFAULTS["Eam1"]), 500.0)
Ea2 = st.sidebar.slider("Ea2", 5000.0, 90000.0, float(DEFAULTS["Ea2"]), 500.0)

st.sidebar.subheader("Environment")
TdegC = st.sidebar.slider("T (°C)", 5.0, 60.0, float(DEFAULTS["TdegC"]), 1.0)
pH = st.sidebar.slider("pH", 3.0, 11.0, float(DEFAULTS["pH"]), 0.1)
pKaA = st.sidebar.slider("pKaA", 3.0, 9.0, float(DEFAULTS["pKaA"]), 0.1)
pKaB = st.sidebar.slider("pKaB", 5.0, 11.0, float(DEFAULTS["pKaB"]), 0.1)

st.sidebar.subheader("Inhibition (optional)")
inhibition_type = st.sidebar.selectbox("Type", ["None", "Competitive"])
inhibitor_I = st.sidebar.number_input("[I] (arbitrary)", min_value=0.0, value=0.0, step=0.1)
Ki = st.sidebar.number_input("Ki (arbitrary)", min_value=0.0, value=1e12, step=1.0)

params = dict(Etotal=Etotal, S0=S0, P0=0.0, k1ref=k1ref, km1ref=km1ref, k2ref=k2ref,
              Ea1=Ea1, Eam1=Eam1, Ea2=Ea2, TdegC=TdegC, pH=pH, pKaA=pKaA, pKaB=pKaB,
              tmax=tmax, inhibition_type=inhibition_type, inhibitor_I=inhibitor_I, Ki=Ki)

# Tabs
learn_tab, play_tab, explore_tab = st.tabs(["Learn", "Play (Real-Time)", "Explore"])

# ------------------------- LEARN TAB -------------------------
with learn_tab:
    st.subheader("1) Run Simulation")
    col1, col2 = st.columns([2, 1])

    res = simulate_nanozyme(params)

    with col1:
        fig1, ax1 = plt.subplots()
        ax1.plot(res.t, res.S, label="[S]")
        ax1.plot(res.t, res.ES, label="[ES]")
        ax1.plot(res.t, res.P, label="[P]")
        ax1.set_xlabel("t (s)")
        ax1.set_ylabel("Concentration (arb)")
        ax1.legend()
        st.pyplot(fig1)

    with col2:
        st.markdown("**Key Metrics**")
        st.write({
            "v0": round(res.metrics["v0"], 4),
            "vmax(app)": round(res.metrics["vmaxApp"], 4),
            "t90 (s)": (None if np.isnan(res.metrics["t90"]) else round(res.metrics["t90"], 2)),
            "Yield@tmax": round(res.metrics["YieldAtTmax"], 4),
        })

# ------------------------- PLAY TAB (REAL-TIME) -------------------------
with play_tab:
    st.subheader("Gamified Challenges — Real-Time Play")

    # BUILT-IN or CUSTOM challenge chooser
    mode = st.radio("Challenge Source", ["Built-in", "Custom"], horizontal=True)

    if mode == "Built-in":
        level_key = st.selectbox("Choose level", list(BUILTIN_CHALLENGES.keys()))
        st.session_state.current_target = BUILTIN_CHALLENGES[level_key]["target"].copy()
        st.session_state.current_hint = BUILTIN_CHALLENGES[level_key]["hint"]
        st.session_state.current_name = BUILTIN_CHALLENGES[level_key]["name"]
    else:
        st.session_state.current_name = st.text_input("Challenge Name", value="My Custom Challenge")
        ctype = st.selectbox("Type", ["Yield target", "Min v0 target"], help="Choose the scoring basis")
        if ctype == "Yield target":
            ytar = st.slider("Yield target", 0.1, 0.99, 0.80, 0.01)
            tlim = st.number_input("Time limit (s)", min_value=10.0, value=120.0, step=10.0)
            emax = st.number_input("Max Etotal", min_value=0.1, value=2.0, step=0.1)
            st.session_state.current_target = {"Yield": ytar, "TimeLimit": tlim, "MaxEtotal": emax}
        else:
            vmin = st.number_input("Min v0", min_value=0.001, value=0.15, step=0.01)
            tlim = st.number_input("Time limit (s)", min_value=10.0, value=100.0, step=10.0)
            emax = st.number_input("Max Etotal", min_value=0.1, value=1.0, step=0.1)
            st.session_state.current_target = {"MinV0": vmin, "TimeLimit": tlim, "MaxEtotal": emax}
        st.session_state.current_hint = "Tune parameters to meet your custom goal."

    # Game controls
    colA, colB, colC = st.columns([1,1,2])
    with colA:
        if not st.session_state.game_active:
            if st.button("Start Game", type="primary"):
                st.session_state.game_active = True
                st.session_state.game_start = time.time()
        else:
            if st.button("Stop Game"):
                st.session_state.game_active = False
    with colB:
        if st.button("Reset Best Score"):
            st.session_state.best_score = 0
            st.toast("Best score reset.")
    with colC:
        st.write(f"**Current Challenge:** {st.session_state.current_name}")
        st.caption(st.session_state.current_hint)

    # Real-time refresh while game is active
    if st.session_state.game_active:
      try:
        st.rerun()
      except AttributeError:
        # For backward compatibility with older Streamlit versions
        try:
            import streamlit.runtime.scriptrunner as scriptrunner
            scriptrunner.RerunException
        except Exception:
            pass

    # Evaluate run and score live
    res_play = simulate_nanozyme(params)
    score = score_run(params, res_play, st.session_state.current_target)
    st.session_state.best_score = max(st.session_state.best_score, score)

    # Time display
    if st.session_state.game_active and st.session_state.game_start:
        elapsed = time.time() - st.session_state.game_start
        st.metric("Elapsed (s)", f"{elapsed:0.0f}")
        if elapsed > st.session_state.current_target.get("TimeLimit", 1e9):
            st.warning("You’re beyond the time limit — penalties may apply.")

    # Live plots and meters
    c1, c2 = st.columns([2,1])
    with c1:
        fig2, ax2 = plt.subplots()
        ax2.plot(res_play.t, res_play.P, label="[P]")
        ax2.set_xlabel("t (s)")
        ax2.set_ylabel("Product [P]")
        ax2.legend()
        st.pyplot(fig2)

    with c2:
        st.metric("Score (live)", score)
        st.metric("Best score", st.session_state.best_score)
        tip = mentor_tip(res_play)
        st.info(tip)

        tgt = st.session_state.current_target
        if "Yield" in tgt:
            st.markdown("**Goal: Yield at tmax**")
            st.progress(clamp01(res_play.metrics["YieldAtTmax"] / max(tgt["Yield"], 1e-9)))
        else:
            st.markdown("**Goal: v0**")
            st.progress(clamp01(res_play.metrics["v0"] / max(tgt["MinV0"], 1e-9)))

    # Record attempt button
    if st.button("Record Attempt"):
        attempt = dict(
            when=time.strftime("%Y-%m-%d %H:%M:%S"),
            challenge=st.session_state.current_name,
            score=score,
            params=params.copy(),
            metrics=res_play.metrics.copy()
        )
        st.session_state.history.append(attempt)
        st.success("Attempt recorded.")

    if st.session_state.history:
        st.markdown("### Attempt History")
        st.dataframe(st.session_state.history)

# ------------------------- EXPLORE TAB -------------------------
with explore_tab:
    st.subheader("Parameter Surfaces")

    st.markdown("**Yield vs pH & Temperature**")
    n_ph = st.slider("Resolution (pH)", 10, 40, 20)
    n_T = st.slider("Resolution (T)", 10, 40, 20)

    ph_grid = np.linspace(3.0, 11.0, n_ph)
    T_grid = np.linspace(5.0, 60.0, n_T)

    Y = np.zeros((n_T, n_ph))
    for i, T_deg in enumerate(T_grid):
        for j, ph_val in enumerate(ph_grid):
            par = params.copy()
            par["TdegC"] = float(T_deg)
            par["pH"] = float(ph_val)
            try:
                r = simulate_nanozyme(par)
                Y[i, j] = r.metrics["YieldAtTmax"]
            except Exception:
                Y[i, j] = np.nan

    fig3, ax3 = plt.subplots()
    im = ax3.imshow(Y, origin="lower", aspect="auto",
                    extent=[ph_grid.min(), ph_grid.max(), T_grid.min(), T_grid.max()])
    ax3.set_xlabel("pH")
    ax3.set_ylabel("T (°C)")
    plt.colorbar(im, ax=ax3, label="Yield@tmax")
    st.pyplot(fig3)

    st.markdown("**v0 vs Etotal & k2ref**")
    n_E = st.slider("Resolution (Etotal)", 10, 40, 20)
    n_k2 = st.slider("Resolution (k2ref)", 10, 40, 20)

    E_grid = np.linspace(0.1, 5.0, n_E)
    k2_grid = np.linspace(0.01, 1.0, n_k2)

    V = np.zeros((n_k2, n_E))
    for i, k2 in enumerate(k2_grid):
        for j, E in enumerate(E_grid):
            par = params.copy()
            par["k2ref"] = float(k2)
            par["Etotal"] = float(E)
            try:
                r = simulate_nanozyme(par)
                V[i, j] = r.metrics["v0"]
            except Exception:
                V[i, j] = np.nan

    fig4, ax4 = plt.subplots()
    im2 = ax4.imshow(V, origin="lower", aspect="auto",
                     extent=[E_grid.min(), E_grid.max(), k2_grid.min(), k2_grid.max()])
    ax4.set_xlabel("Etotal")
    ax4.set_ylabel("k2ref @25°C")
    plt.colorbar(im2, ax=ax4, label="v0")
    st.pyplot(fig4)